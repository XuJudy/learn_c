### P1319 压缩技术

#### 题目描述
设某汉字由N×N的0和1的点阵图案组成。我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个0，第二个数表示接下来连续有几个1，第三个数再接下来连续有几个0，第四个数接着连续几个1，以此类推……
例如: 以下汉字点阵图案：
```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```
对应的压缩码是：7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 （第一个数是N ,其余各位表示交替表示0和1的个数，压缩码保证N×N=交替的各位数之和

#### 输入格式
数据输入一行，由空格隔开的若干个整数，表示压缩码。
其中，压缩码的第一个数字就是N，表示这个点阵应当是N×N的大小。
接下来的若干个数字，含义如题目描述所述。

#### 输出格式
输出一个N×N的01矩阵，表示最后的汉字点阵图（点阵符号之间不留空格）。

#### 输入输出样例

###### 输入 #1
` 7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 `

###### 输出 #1
```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

---

#### 解題思路
1. 邊讀取邊輸出，不用用到數組。
2. 利用r統計總共要輸出的數量。  `r = N * N`
3. cnt則是下一組0/1的數量。  `r = r - cnt`
4. word來統計該行已輸出的數字數量，當 `word==N` 時要換行。
5. 利用num紀錄正在輸出的數字(1or0)，每輸出完一組要數字，num=1時，下一組則要輸出0。  `num = (num==1? 0:1)`

#### 完整代碼
```c
// P1319 压缩技术

#include<stdio.h>

int main(){

    int N;
    int cnt;
    int num = 0;
    int word = 0;

    scanf("%d", &N);

    int r = N*N;
    
    while(r){

        scanf("%d", &cnt);

        r = r - cnt;

        for(int i=0; i<cnt; i++){

            if(word==N){
                
                word = 0;
                printf("\n");
            }

            word++;
            printf("%d", num);
        }

        num = ((num==1)?0:1);
    }

    return 0;
}
```

---

### P1320 压缩技术（续集版）

#### 输入格式
汉字点阵图（点阵符号之间不留空格）。

#### 输出格式
输出一行，压缩码。

#### 输入输出样例

###### 输入 #1
```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

###### 输出 #1
` 7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 `

---

#### 解題思路
1. 讀入字符串並計算sum。
2. 將sum開根號算出是N*N的矩陣。    `N = sqrt(sum)`
3. 利用一維數組存儲壓縮碼，後輸出。

#### 完整代碼
```c
// P1320 压缩技术（续集版）

#include<stdio.h>
#include<math.h>

int main(){

    char input;
    int sum = 0;     // 總輸入數字的數量
    int flag = 0;    // 標記當下是統計1/0數量(從0開始)
    int type = 0;
    int num[200] = {0};

    while(scanf("%c", &input)!=EOF){

        if(input=='\n') continue;

            sum++;
            input = input - '0';
            
            if(input==flag){

                num[type]++;
            }
            else{

                flag = input;
                num[++type]++;
            }
    }

    printf("%d ", (int)sqrt(sum));

    for(int i=0; i<=type; i++){

        printf("%d ", num[i]);
    }

    return 0;
}
```
